
Meeting
    - compute beta, not fluxes
    - plug in c++ result to python to check
    - run smooth constraint with true sgn but with approx derivatives
    - set big M value to be 50
        - note: the makes some of the relaxed regualtion upper bounds infeasible
            - 200 seems to be about lowest possible
    - change y sign relax constraint to python version

TODO:
    - remove all instances of auto
        - see: https://stackoverflow.com/questions/29231798/eigen-how-to-make-a-deep-copy-of-a-matrix
    - set all initial variables base on metabolitees and beta
    - move metabolite lower upper bounds to variables


Ideas 
----------------------------------------------------
    - try with other smooth constraint
    - try reading in null_space matrix
        - make sure flux vars are close to zero
    - check constraints again
        - test with small inputs and print out
    - flip const class sign
    - run eigen and ifopt in production mode
    - better solver: HSL ma57
        - https://www.hsl.rl.ac.uk/download/coinhsl/2021.05.05/
    - try different jacobian for max ent problem formulation equation 96
    - loosen equality bounds, since IFOPT might remove them from problem


Questions for Ethan
    - m.SvS is never used

****************************************************************************
USAGE NOTES
****************************************************************************

DO NOT EVER USE auto types with eigen
    - https://stackoverflow.com/questions/29231798/eigen-how-to-make-a-deep-copy-of-a-matrix

ifopt does not do variable indices like pyomo. This came up when 
    separating the variable metabolites from the fixed metabolites and also
    when fitting the target_counts to be the same size as the variable metabolites.
    The python code seemed to just select the variable metabolites from the
    front of the array, so this is what I did.

eigen objects of fixed size and any object that contains an eigin object of fixed size MUST be 
    passed by reference and never by value. or else memory become unaligned. 
    Returning by value is fine though.

when we are assigning a matrix expression to a matrix that appears
    in the expression, be sure to call .eval() on the RHS.
    Ex. A = A * B; should be A = (A * B).eval();

matrix_t A = B; performs a deep copy of B into A.

numpy array operation * is elementwise

eigen is lazy.
    - use .eval() to force strict evaluation of RHS.
    - this is particularly important for aliasing.
    - HOWEVER, component-wise operations are safe regardless
        and don't require forced evaluation.
        - "In general, an assignment is safe if the (i,j) 
            entry of the expression on the right-hand side 
            depends only on the (i,j) entry of the matrix or 
            array on the left-hand side and not on any other entries"

eigen in general does not perform operations in-place.
    - when an in-place alternative for func() exist, 
        it is usually called funcInPlace().


eigen matrix.reshaped() or .resize()?
    resize changes the matrix in place,
        whereas reshaped returns a new matrix.
    no way to specify coefficient order for resize.
    *resizing (both increasing and decreasing total 
        number of coefficients) will delete the current
        coefficients (replace with zeros) UNLESS the 
        total number of coefficients is unchanged.

matrix types only support linear -algebra operations, for 
    component wise operations, one must first call the matrix.array()
    to convert the matrix to an array.
    At the end of the operations, one then must call .matrix() 
    to convert the array back into a mtraix.
    

IFOPT/EIGEN INSTALL NOTES:
    cmake flags: -DCMAKE_CXX_FLAGS="-std=c++17 " -DCMAKE_INSTALL_PREFIX=/path/to/metab

https://list.coin-or.org/pipermail/ipopt/2015-July/004087.html
https://stackoverflow.com/questions/34138879/unable-to-find-eigen3-with-cmake



    